/*! shopify/storefront-api-client@0.3.0 -- Copyright (c) 2023-present, Shopify Inc. -- license (MIT): https://github.com/Shopify/shopify-api-js/blob/main/LICENSE.md */
!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).ShopifyStorefrontAPIClient={})}(this,(function(e){"use strict";const r="GraphQL Client",t=0,n=3,o="An error occurred while fetching from the API. Review 'graphQLErrors' for details.",s="Response returned unexpected Content-Type:",i="An unknown error has occurred. The API did not return a data object or any errors in its response.",a={json:"application/json",multipart:"multipart/mixed"},c=1e3,u=[429,503],l=/@(defer)\b/i,p=/boundary="?([^=";]+)"?/i,d="\r\n\r\n";function f(e,t=r){return e.startsWith(`${t}`)?e:`${t}: ${e}`}function h(e){return e instanceof Error?e.message:JSON.stringify(e)}function y(e){return e instanceof Error&&e.cause?e.cause:void 0}function m(e){return e.flatMap((({errors:e})=>e??[]))}function g({client:e,retries:r}){if(void 0!==r&&("number"!=typeof r||r<t||r>n))throw new Error(`${e}: The provided "retries" value (${r}) is invalid - it cannot be less than ${t} or greater than ${n}`)}function w(e,r){return r&&("object"!=typeof r||Array.isArray(r)||"object"==typeof r&&Object.keys(r).length>0)?{[e]:r}:{}}function b(e,r){if(0===e.length)return r;const t={[e.pop()]:r};return 0===e.length?t:b(e,t)}function $(e,r){return Object.keys(r||{}).reduce(((t,n)=>("object"==typeof r[n]||Array.isArray(r[n]))&&e[n]?(t[n]=$(e[n],r[n]),t):(t[n]=r[n],t)),Array.isArray(e)?[...e]:{...e})}function A([e,...r]){return r.reduce($,{...e})}function S({clientLogger:e,customFetchApi:t=fetch,client:n=r,defaultRetryWaitTime:o=c,retriableCodes:s=u}){const i=async(r,a,c)=>{const u=a+1,l=c+1;let p;try{if(p=await t(...r),e({type:"HTTP-Response",content:{requestParams:r,response:p}}),!p.ok&&s.includes(p.status)&&u<=l)throw new Error;return p}catch(t){if(u<=l){const t=p?.headers.get("Retry-After");return await async function(e){return new Promise((r=>setTimeout(r,e)))}(t?parseInt(t,10):o),e({type:"HTTP-Retry",content:{requestParams:r,lastResponse:p,retryAttempt:a,maxRetries:c}}),i(r,u,c)}throw new Error(f(`${c>0?`Attempted maximum number of ${c} network retries. Last message - `:""}${h(t)}`,n))}};return i}function v({headers:e,url:t,customFetchApi:n=$,retries:o=0,logger:i}){g({client:r,retries:o});const u={headers:e,url:t,retries:o},b=function(e){return r=>{e&&e(r)}}(i),$=function(e,{url:t,headers:n,retries:o}){return async(s,i={})=>{const{variables:a,headers:c,url:u,retries:l}=i,p=JSON.stringify({query:s,variables:a});g({client:r,retries:l});const d=Object.entries({...n,...c}).reduce(((e,[r,t])=>(e[r]=Array.isArray(t)?t.join(", "):t.toString(),e)),{});return e([u??t,{method:"POST",headers:d,body:p}],1,l??o)}}(S({customFetchApi:n,clientLogger:b,defaultRetryWaitTime:c}),u),v=function(e){return async(...r)=>{if(l.test(r[0]))throw new Error(f("This operation will result in a streamable response - use requestStream() instead."));try{const t=await e(...r),{status:n,statusText:o}=t,i=t.headers.get("content-type")||"";return t.ok?i.includes(a.json)?x(t):{errors:{networkStatusCode:n,message:f(`${s} ${i}`),response:t}}:{errors:{networkStatusCode:n,message:f(o),response:t}}}catch(e){return{errors:{message:h(e)}}}}}($),k=function(e){return async(...r)=>{if(!l.test(r[0]))throw new Error(f("This operation does not result in a streamable response - use request() instead."));try{const t=await e(...r),{statusText:n}=t;if(!t.ok)throw new Error(n,{cause:t});const o=t.headers.get("content-type")||"";switch(!0){case o.includes(a.json):return function(e){return{async*[Symbol.asyncIterator](){const r=await x(e);yield{...r,hasNext:!1}}}}(t);case o.includes(a.multipart):return function(e,r){const t=(r??"").match(p),n=`--${t?t[1]:"-"}`;if(!e.body?.getReader&&!e.body[Symbol.asyncIterator])throw new Error("API multipart response did not return an iterable body",{cause:e});const o=async function*(e){if(e.body[Symbol.asyncIterator])for await(const r of e.body)yield r.toString();else{const r=e.body.getReader(),t=new TextDecoder;let n;try{for(;!(n=await r.read()).done;)yield t.decode(n.value)}finally{r.cancel()}}}(e);let s,i={};return{async*[Symbol.asyncIterator](){try{let e=!0;for await(const r of function(e,r){return{async*[Symbol.asyncIterator](){try{let t="";for await(const n of e)if(t+=n,t.indexOf(r)>-1){const e=t.lastIndexOf(r),n=t.slice(0,e).split(r).filter((e=>e.trim().length>0)).map((e=>e.slice(e.indexOf(d)+d.length).trim()));n.length>0&&(yield n),t=t.slice(e+r.length),"--"===t.trim()&&(t="")}}catch(e){throw new Error(`Error occured while processing stream payload - ${h(e)}`)}}}}(o,n)){const t=E(r);s=t.find((e=>e.extensions))?.extensions??s;const n=m(t);i=A([i,...t.map((({data:e})=>e))]),e=t.slice(-1)[0].hasNext,T(n,i),yield{...w("data",i),...w("extensions",s),hasNext:e}}if(e)throw new Error("Response stream terminated unexpectedly")}catch(r){const t=y(r);yield{...w("data",i),...w("extensions",s),errors:{message:f(h(r)),networkStatusCode:e.status,...w("graphQLErrors",t?.graphQLErrors),response:e},hasNext:!1}}}}}(t,o);default:throw new Error(`${s} ${o}`,{cause:t})}}catch(e){return{async*[Symbol.asyncIterator](){const r=y(e);yield{errors:{message:f(h(e)),...w("networkStatusCode",r?.status),...w("response",r)},hasNext:!1}}}}}}($);return{config:u,fetch:$,request:v,requestStream:k}}async function x(e){const{errors:r,data:t,extensions:n}=await e.json();return{...w("data",t),...w("extensions",n),...r||!t?{errors:{networkStatusCode:e.status,message:f(r?o:i),...w("graphQLErrors",r),response:e}}:{}}}function E(e){return e.map((e=>{try{return JSON.parse(e)}catch(e){throw new Error(`Error in parsing multipart response - ${h(e)}`)}})).map((e=>{const{data:r,incremental:t,hasNext:n,extensions:o,errors:s}=e;if(!t)return{data:r||{},...w("errors",s),...w("extensions",o),hasNext:n};const i=t.map((({data:e,path:r,errors:t})=>({data:e&&r?b(r,e):{},...w("errors",t)})));return{data:1===i.length?i[0].data:A([...i.map((({data:e})=>e))]),...w("errors",m(i)),hasNext:n}}))}function T(e,r){if(e.length>0)throw new Error(o,{cause:{graphQLErrors:e}});if(0===Object.keys(r).length)throw new Error(i)}function k({client:e,currentSupportedApiVersions:r,apiVersion:t,logger:n}){const o=`${e}: the provided apiVersion ("${t}")`,s=`Currently supported API versions: ${r.join(", ")}`;if(!t||"string"!=typeof t)throw new Error(`${o} is invalid. ${s}`);const i=t.trim();r.includes(i)||(n?n({type:"Unsupported_Api_Version",content:{apiVersion:t,supportedApiVersions:r}}):console.warn(`${o} is likely deprecated or not supported. ${s}`))}function j(e){const r=3*e-2;return 10===r?r:`0${r}`}function C(e,r,t){const n=r-t;return n<=0?`${e-1}-${j(n+4)}`:`${e}-${j(n)}`}function I(){const{year:e,quarter:r,version:t}=function(){const e=new Date,r=e.getUTCMonth(),t=e.getUTCFullYear(),n=Math.floor(r/3+1);return{year:t,quarter:n,version:`${t}-${j(n)}`}}(),n=4===r?`${e+1}-01`:`${e}-${j(r+1)}`;return[C(e,r,3),C(e,r,2),C(e,r,1),t,n,"unstable"]}const V="application/json",q="Storefront API Client";e.createStorefrontApiClient=function({storeDomain:e,apiVersion:r,publicAccessToken:t,privateAccessToken:n,clientName:o,retries:s=0,customFetchApi:i,logger:a}){const c=I(),u=function({client:e,storeDomain:r}){try{if(!r||"string"!=typeof r)throw new Error;const e=r.trim(),t=e.match(/^https?:/)?e:`https://${e}`,n=new URL(t);return n.protocol="https",n.origin}catch(t){throw new Error(`${e}: a valid store domain ("${r}") must be provided`)}}({client:q,storeDomain:e}),l={client:q,currentSupportedApiVersions:c,logger:a};k({...l,apiVersion:r}),function(e,r){if(!e&&!r)throw new Error(`${q}: a public or private access token must be provided`);if(e&&r)throw new Error(`${q}: only provide either a public or private access token`)}(t,n),function(e){if(e&&"undefined"!=typeof window)throw new Error(`${q}: private access tokens and headers should only be used in a server-to-server implementation. Use the public API access token in nonserver environments.`)}(n);const p=function(e,r,t){return n=>{n&&k({...t,apiVersion:n});const o=(n??r).trim();return`${e}/api/${o}/graphql.json`}}(u,r,l),d={storeDomain:u,apiVersion:r,...t?{publicAccessToken:t}:{privateAccessToken:n},headers:{"Content-Type":V,Accept:V,"X-SDK-Variant":"storefront-api-client","X-SDK-Version":"0.3.0",...o?{"X-SDK-Variant-Source":o}:{},...t?{"X-Shopify-Storefront-Access-Token":t}:{"Shopify-Storefront-Private-Token":n}},apiUrl:p(),clientName:o},f=v({headers:d.headers,url:d.apiUrl,retries:s,customFetchApi:i,logger:a}),h=function(e){return r=>({...r??{},...e.headers})}(d),y=function(e,r){return t=>t?r(t):e.apiUrl}(d,p),m=function({getHeaders:e,getApiUrl:r}){return(t,n)=>{const o=[t];if(n&&Object.keys(n).length>0){const{variables:t,apiVersion:s,headers:i,retries:a}=n;o.push({...t?{variables:t}:{},...i?{headers:e(i)}:{},...s?{url:r(s)}:{},...a?{retries:a}:{}})}return o}}({getHeaders:h,getApiUrl:y}),g={config:d,getHeaders:h,getApiUrl:y,fetch:(...e)=>f.fetch(...m(...e)),request:(...e)=>f.request(...m(...e)),requestStream:(...e)=>f.requestStream(...m(...e))};return Object.freeze(g)}}));
//# sourceMappingURL=storefront-api-client.min.js.map
